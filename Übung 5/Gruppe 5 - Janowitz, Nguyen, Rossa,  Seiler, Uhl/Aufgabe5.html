<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.14: http://docutils.sourceforge.net/" />
<title>Gruppe 5 - Übung 5</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7952 2016-07-26 18:15:59Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

.subscript {
  vertical-align: sub;
  font-size: smaller }

.superscript {
  vertical-align: super;
  font-size: smaller }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left, table.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right, table.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

table.align-center {
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

.align-top    {
  vertical-align: top }

.align-middle {
  vertical-align: middle }

.align-bottom {
  vertical-align: bottom }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #eeeeee }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

/* "booktabs" style (no vertical lines) */
table.docutils.booktabs {
  border: 0px;
  border-top: 2px solid;
  border-bottom: 2px solid;
  border-collapse: collapse;
}
table.docutils.booktabs * {
  border: 0px;
}
table.docutils.booktabs th {
  border-bottom: thin solid;
  text-align: left;
}

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="gruppe-5-ubung-5">
<h1 class="title">Gruppe 5 - Übung 5</h1>

<p>Von:    Ivo Janowitz, Nguyen Anh Quang, Tillman Rossa, Roman Seiler, Alexander Uhl</p>
<div class="section" id="timespow">
<h1>1. Timespow</h1>
<blockquote>
<blockquote>
<p><strong>Aufgabe 1</strong></p>
<ul class="simple">
<li>Schreiben Sie eine Lösung für den kurzen Test timespow.s aus der letzten                        Veranstaltung. Der Code befindet sich im Git Repository sysprog</li>
</ul>
<blockquote>
<pre class="code literal-block">
# Systemnahe Programmierung - Testen Sie Ihre Kenntnisse!
# H. Hoegl, 2012-11-08

#   timespow(3, 2) + timespow(2, 3)

    .section .data
    .section .text
    .globl _start

_start:
    pushl $1        # b
    pushl $7        # x
    call  timespow2
    addl  $8, %esp
    pushl %eax
    pushl $0        # b
    pushl $2        # x
    call  timespow2
    addl  $8, %esp
    popl  %ebx
    addl %eax, %ebx
    movl $1, %eax
    int $0x80


# timespow2(x, b)
#   return x * 2^b
#   Trick: x * 2^b = shift argument x left by b bits
#                    shll %cl, %ebx  (shift ebx left by cl bits)
.type timespow2, &#64;function
timespow2:
    pushl %ebp            # 1 Prolog
    movl %esp, %ebp       # 2 Prolog
    movl 12(%ebp), %ebx   # 3 Argument holen
    movb 8(%ebp), %cl     # 4 Argument holen
    shll %cl, %ebx        # 5 Schieben
    movl %ebx, %eax       # 6 Ergebnis ablegen
    movl %ebp, %esp       # 7 Epilog
    popl %ebp             # 8 Epilog
    ret                   # 9 Zurueckkehren

</pre>
</blockquote>
</blockquote>
<div class="line-block">
<div class="line"><br /></div>
</div>
</blockquote>
</div>
<div class="section" id="selbst-ubung">
<h1>2. Selbst Übung</h1>
<blockquote>
<blockquote>
<p><strong>Aufgabe 2</strong></p>
<ul class="simple">
<li>Vollziehen Sie das im Kapitel 5 (Bartlett) beschriebene Programm mit dem Debugger gdb                   nach</li>
</ul>
</blockquote>
<div class="line-block">
<div class="line"><br /></div>
</div>
</blockquote>
</div>
<div class="section" id="toupper-in-anderen-sprachen">
<h1>3. ToUpper in anderen Sprachen</h1>
<blockquote>
<blockquote>
<p><strong>Aufgabe 3</strong></p>
<ul class="simple">
<li>Formulieren Sie das Programm aus Kapitel 5 in den Sprachen</li>
</ul>
</blockquote>
<div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<p><strong>ToUpper in C</strong></p>
<blockquote>
<pre class="code literal-block">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

#define NOREAD &quot;\nQuelldatei konnte nicht gefunden werden&quot;
#define NOWRITE &quot;\nZieldatei konnte nicht geöffnet werden&quot;
#define NOCOPY &quot;\nQuelldatei kann icht auf sich selbst kopiert werden&quot;

int main(int argc, char *argv[]) {

    void upstr(char *s);

    FILE *infile = stdin;
    FILE *outfile = stdout;

    char sbuf[512];
    int i;

    if (argc != 3){
        fputs(&quot;Richtige Params angeben&quot;, stderr);
        exit(1);
    }

    infile = fopen(argv[1], &quot;r&quot;);
    outfile = fopen(argv[2], &quot;w&quot;);

    while(fgets(sbuf, 512, infile) != NULL){
        upstr(sbuf);
        fputs(sbuf, outfile);
    }

    fcloseall();
}

void upstr(char *s){
    int i = 0;

    while (s[i]){
        s[i] = toupper(s[i]);
        i++;
    }
}
</pre>
</blockquote>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p><strong>ToUpper in Java</strong></p>
<blockquote>
<pre class="code literal-block">
import java.io.*;

class toupper {
    public static void main(String args[]) {

        BufferedReader br;
        String everything = &quot;&quot;;

        try {
            br = new BufferedReader(new FileReader(args[0]));
            StringBuilder sb = new StringBuilder();
            String line = br.readLine();

            while (line != null) {
                sb.append(line);
                sb.append(System.lineSeparator());
                line = br.readLine();
            }
            everything = sb.toString();
        } catch (IOException e){
            e.printStackTrace();
        }
        everything = everything.toUpperCase();
        try {
            PrintWriter out = new PrintWriter(args[1]);
            out.println(everything);
            out.close();
        } catch (FileNotFoundException e){
            e.printStackTrace();
        }

    }
}
</pre>
</blockquote>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p><strong>ToUpper in Python</strong></p>
<blockquote>
<pre class="code literal-block">
import sys

# first element is pythonscript filename
if len(sys.argv) &gt;= 3:
        name_in = sys.argv[1]
        name_out = sys.argv[2]

        with open(name_in, 'r' ) as file_in, open(name_out, 'w') as file_out:
                file_out.write(file_in.read().upper())
</pre>
</blockquote>
</blockquote>
<div class="line-block">
<div class="line"><br /></div>
</div>
</blockquote>
</div>
<div class="section" id="aufgaben-von-kapitel-5-pgu">
<h1>4. Aufgaben von Kapitel 5 PGU</h1>
<blockquote>
<blockquote>
<p><strong>Know the concepts</strong></p>
<blockquote>
<ul>
<li><p class="first">Describe the lifecycle of a file descriptor.</p>
<blockquote>
<p>A file descriptor is created when we open a file until we close it.</p>
</blockquote>
</li>
<li><p class="first">What are the standard file descriptors and what are they used for?</p>
<blockquote>
<p>File Descriptor 0, 1 and 2 are the standard one.
0 is the STDIN, 1 is the STDOUT and 2 is the STDERR
Where STDIN represend the default keyboard, STDOUT the screen and STDERR                                        is the standard error</p>
</blockquote>
</li>
<li><p class="first">What is a buffer?</p>
<blockquote>
<p>A Buffer is a place to store a big junk of data for example from the
read of a file</p>
</blockquote>
</li>
<li><p class="first">What is the difference between the .data section and the .bss section?</p>
<blockquote>
<p>The .data section is static and the .bss is dynamic for one example.
Also the .data section stores the initialized data from the source code
where the .bss holds temporary new data create in the runtime</p>
</blockquote>
</li>
<li><p class="first">What are the system calls related to reading and writing files?</p>
<blockquote>
<pre class="code literal-block">
movl $5, %eax   #Open
int 0x80

movl $4, %eax   #Write
int 0x80

movl $3, %eax   #Read
int 0x80

movl $6, %eax   #Close
int 0x80
</pre>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<p><strong>Use the concepts</strong></p>
<ul>
<li><p class="first">Modify the toupper program so that it reads from STDIN and writes to STDOUT instead of using the files on the command-line.</p>
<blockquote>
<pre class="code literal-block">
# -*- indent-tabs-mode: nil -*- (for Emacs)

# PURPOSE: This program converts an input file
# to an output file with all letters
# converted to uppercase.
#
# PROCESSING:
# 1) Open the input file
# 2) Open the output file
# 4) While we're not at the end of the input file
#    a) read part of file into our memory buffer
#    b) go through each byte of memory
#       if the byte is a lower-case letter,
#       convert it to uppercase
#    c) write the memory buffer to output file


        .section .data

        #######CONSTANTS########
        # system call numbers
        .equ SYS_OPEN, 5
        .equ SYS_WRITE, 4
        .equ SYS_READ, 3
        .equ SYS_CLOSE, 6
        .equ SYS_EXIT, 1

        # options for open (look at
        # /usr/include/asm/fcntl.h for
        # various values. You can combine them
        # by adding them or ORing them)
        # This is discussed at greater length
        # in &quot;Counting Like a Computer&quot;
        .equ O_RDONLY, 0
        .equ O_CREAT_WRONLY_TRUNC, 03101

        # standard file descriptors
        .equ STDIN, 0
        .equ STDOUT, 1
        .equ STDERR, 2

        # system call interrupt
        .equ LINUX_SYSCALL, 0x80
        .equ END_OF_FILE, 0 #This is the return value

        # of read which means we've
        # hit the end of the file
        .equ NUMBER_ARGUMENTS, 2

        .section .bss

        # Buffer - this is where the data is loaded into
        # from the data file and written from
        # into the output file. This should
        # never exceed 16,000 for various
        # reasons.
        .equ BUFFER_SIZE, 500
        .lcomm BUFFER_DATA, BUFFER_SIZE

        .section .text

        # STACK POSITIONS
        .equ ST_SIZE_RESERVE, 8
        .equ ST_FD_IN, -4
        .equ ST_FD_OUT, -8
        .equ ST_ARGC, 0         # Number of arguments
        .equ ST_ARGV_0, 4       # Name of program
        .equ ST_ARGV_1, 8       # Input file name
        .equ ST_ARGV_2, 12      # Output file name
        .globl _start

_start:
        ### INITIALIZE PROGRAM ###
        # save the stack pointer

        movl %esp, %ebp

        # Allocate space for our file descriptors
        # on the stack
        subl $ST_SIZE_RESERVE, %esp

store_fd_in:
        # save the given file descriptor
        movl $0, ST_FD_IN(%ebp)

store_fd_out:
        # store the file descriptor here
        movl $1, ST_FD_OUT(%ebp)

                                # BEGIN MAIN LOOP
read_loop_begin:
                                   # READ IN A BLOCK FROM THE INPUT FILE
        movl $SYS_READ, %eax
        movl ST_FD_IN(%ebp), %ebx  # get the input file descriptor
        movl $BUFFER_DATA, %ecx    # the location to read into
        movl $BUFFER_SIZE, %edx    # the size of the buffer
        int $LINUX_SYSCALL         # Size of buffer read is returned in %eax
        cmpl $END_OF_FILE, %eax    # check for end of file marker
                                   # if found or on error, go to the end
        jle end_loop
continue_read_loop:
        ### CONVERT THE BLOCK TO UPPER CASE ###
        pushl $BUFFER_DATA      # location of buffer
        pushl %eax              # size of the buffer
        call convert_to_upper
        popl %eax               # get the size back
        addl $4, %esp           # restore %esp
        ### WRITE THE BLOCK OUT TO THE OUTPUT FILE ###
        movl %eax, %edx         # size of the buffer
        movl $SYS_WRITE, %eax
        movl ST_FD_OUT(%ebp), %ebx  # file to use
        movl $BUFFER_DATA, %ecx     # location of the buffer
        int $LINUX_SYSCALL
        jmp read_loop_begin

end_loop:
                                ###CLOSE THE FILES###
                                # NOTE - we don't need to do error checking
                                # on these, because error conditions
                                # don't signify anything special here
        movl $SYS_CLOSE, %eax
        movl ST_FD_OUT(%ebp), %ebx
        int $LINUX_SYSCALL
        movl $SYS_CLOSE, %eax
        movl ST_FD_IN(%ebp), %ebx
        int $LINUX_SYSCALL
                                ### EXIT ###
        movl $SYS_EXIT, %eax
        movl $0, %ebx
        int $LINUX_SYSCALL


#PURPOSE: This function actually does the
# conversion to upper case for a block
#
#INPUT: The first parameter is the location

# of the block of memory to convert
# The second parameter is the length of
# that buffer
#
#OUTPUT: This function overwrites the current
# buffer with the upper-casified version.
#
#VARIABLES:
# %eax - beginning of buffer
# %ebx - length of buffer
# %edi - current buffer offset
# %cl - current byte being examined
# (first part of %ecx)

        ### CONSTANTS ##
                                # The lower boundary of our search
        .equ LOWERCASE_A, 'a'
                                # The upper boundary of our search
        .equ LOWERCASE_Z, 'z'
                                # Conversion between upper and lower case
        .equ UPPER_CONVERSION, 'A' - 'a'
                                ### STACK STUFF ###
        .equ ST_BUFFER_LEN, 8   # Length of buffer
        .equ ST_BUFFER, 12      # actual buffer
convert_to_upper:
        pushl %ebp
        movl %esp, %ebp
                        ### SET UP VARIABLES ###
        movl ST_BUFFER(%ebp), %eax
        movl ST_BUFFER_LEN(%ebp), %ebx
        movl $0, %edi

                        # if a buffer with zero length was given
                        # to us, just leave
        cmpl $0, %ebx
        je end_convert_loop
convert_loop:
                        # get the current byte
        movb (%eax,%edi,1), %cl
                        # go to the next byte unless it is between
                        #'a' and 'z'
        cmpb $LOWERCASE_A, %cl
        jl next_byte
        cmpb $LOWERCASE_Z, %cl
        jg next_byte
                        # otherwise convert the byte to uppercase
        addb $UPPER_CONVERSION, %cl
                        # and store it back
        movb %cl, (%eax,%edi,1)

next_byte:
        incl %edi #next byte
        cmpl %edi, %ebx #continue unless
                        # we've reached the end
        jne convert_loop
end_convert_loop:
                        # no return value, just leave
        movl %ebp, %esp
        popl %ebp
        ret

# vim: expandtab sw=8 sts=8
</pre>
</blockquote>
</li>
</ul>
</blockquote>
<div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<p><strong>ToUpper Buffer Version</strong></p>
<ul>
<li><p class="first">Change the size of the buffer.</p>
<blockquote>
<pre class="code literal-block">
# -*- indent-tabs-mode: nil -*- (for Emacs)

# PURPOSE: This program converts an input file
# to an output file with all letters
# converted to uppercase.
#
# PROCESSING:
# 1) Open the input file
# 2) Open the output file
# 4) While we're not at the end of the input file
#    a) read part of file into our memory buffer
#    b) go through each byte of memory
#       if the byte is a lower-case letter,
#       convert it to uppercase
#    c) write the memory buffer to output file


        .section .data

        #######CONSTANTS########
        # system call numbers
        .equ SYS_OPEN, 5
        .equ SYS_WRITE, 4
        .equ SYS_READ, 3
        .equ SYS_CLOSE, 6
        .equ SYS_EXIT, 1

        # options for open (look at
        # /usr/include/asm/fcntl.h for
        # various values. You can combine them
        # by adding them or ORing them)
        # This is discussed at greater length
        # in &quot;Counting Like a Computer&quot;
        .equ O_RDONLY, 0
        .equ O_CREAT_WRONLY_TRUNC, 03101

        # standard file descriptors
        .equ STDIN, 0
        .equ STDOUT, 1
        .equ STDERR, 2

        # system call interrupt
        .equ LINUX_SYSCALL, 0x80
        .equ END_OF_FILE, 0 #This is the return value

        # of read which means we've
        # hit the end of the file
        .equ NUMBER_ARGUMENTS, 2

        .section .bss

        # Buffer - this is where the data is loaded into
        # from the data file and written from
        # into the output file. This should
        # never exceed 16,000 for various
        # reasons.
        .equ BUFFER_SIZE, 20

        #.equ BUFFER_SIZE, 100
        #.equ BUFFER_SIZE, 500
        #.equ BUFFER_SIZE, 100000

        .lcomm BUFFER_DATA, BUFFER_SIZE

        .section .text

        # STACK POSITIONS
        .equ ST_SIZE_RESERVE, 8
        .equ ST_FD_IN, -4
        .equ ST_FD_OUT, -8
        .equ ST_ARGC, 0         # Number of arguments
        .equ ST_ARGV_0, 4       # Name of program
        .equ ST_ARGV_1, 8       # Input file name
        .equ ST_ARGV_2, 12      # Output file name
        .globl _start

_start:
        ### INITIALIZE PROGRAM ###
        # save the stack pointer

        movl %esp, %ebp

        # Allocate space for our file descriptors
        # on the stack
        subl $ST_SIZE_RESERVE, %esp

open_files:
open_fd_in:
                        ### OPEN INPUT FILE ###
                        # open syscall
        movl $SYS_OPEN, %eax
                        # input filename into %ebx
        movl ST_ARGV_1(%ebp), %ebx
                        # read-only flag
        movl $O_RDONLY, %ecx
                        # this doesn't really matter for reading
        movl $0666, %edx
                        # call Linux
        int $LINUX_SYSCALL
store_fd_in:
                        # save the given file descriptor
        movl %eax, ST_FD_IN(%ebp)

open_fd_out:
                                ### OPEN OUTPUT FILE ###
                                # open the file
        movl $SYS_OPEN, %eax
                                # output filename into %ebx
        movl ST_ARGV_2(%ebp), %ebx
                                # flags for writing to the file
        movl $O_CREAT_WRONLY_TRUNC, %ecx
                                # mode for new file (if it's created)
        movl $0666, %edx
                                # call Linux
        int $LINUX_SYSCALL

store_fd_out:
                                # store the file descriptor here
        movl %eax, ST_FD_OUT(%ebp)
                                # BEGIN MAIN LOOP
read_loop_begin:
                                   # READ IN A BLOCK FROM THE INPUT FILE
        movl $SYS_READ, %eax
        movl ST_FD_IN(%ebp), %ebx  # get the input file descriptor
        movl $BUFFER_DATA, %ecx    # the location to read into
        movl $BUFFER_SIZE, %edx    # the size of the buffer
        int $LINUX_SYSCALL         # Size of buffer read is returned in %eax
        cmpl $END_OF_FILE, %eax    # check for end of file marker
                                   # if found or on error, go to the end
        jle end_loop
continue_read_loop:
        ### CONVERT THE BLOCK TO UPPER CASE ###
        pushl $BUFFER_DATA      # location of buffer
        pushl %eax              # size of the buffer
        call convert_to_upper
        popl %eax               # get the size back
        addl $4, %esp           # restore %esp
        ### WRITE THE BLOCK OUT TO THE OUTPUT FILE ###
        movl %eax, %edx         # size of the buffer
        movl $SYS_WRITE, %eax
        movl ST_FD_OUT(%ebp), %ebx  # file to use
        movl $BUFFER_DATA, %ecx     # location of the buffer
        int $LINUX_SYSCALL
        jmp read_loop_begin

end_loop:
                                ###CLOSE THE FILES###
                                # NOTE - we don't need to do error checking
                                # on these, because error conditions
                                # don't signify anything special here
        movl $SYS_CLOSE, %eax
        movl ST_FD_OUT(%ebp), %ebx
        int $LINUX_SYSCALL
        movl $SYS_CLOSE, %eax
        movl ST_FD_IN(%ebp), %ebx
        int $LINUX_SYSCALL
                                ### EXIT ###
        movl $SYS_EXIT, %eax
        movl $0, %ebx
        int $LINUX_SYSCALL


#PURPOSE: This function actually does the
# conversion to upper case for a block
#
#INPUT: The first parameter is the location

# of the block of memory to convert
# The second parameter is the length of
# that buffer
#
#OUTPUT: This function overwrites the current
# buffer with the upper-casified version.
#
#VARIABLES:
# %eax - beginning of buffer
# %ebx - length of buffer
# %edi - current buffer offset
# %cl - current byte being examined
# (first part of %ecx)

        ### CONSTANTS ##
                                # The lower boundary of our search
        .equ LOWERCASE_A, 'a'
                                # The upper boundary of our search
        .equ LOWERCASE_Z, 'z'
                                # Conversion between upper and lower case
        .equ UPPER_CONVERSION, 'A' - 'a'
                                ### STACK STUFF ###
        .equ ST_BUFFER_LEN, 8   # Length of buffer
        .equ ST_BUFFER, 12      # actual buffer
convert_to_upper:
        pushl %ebp
        movl %esp, %ebp
                        ### SET UP VARIABLES ###
        movl ST_BUFFER(%ebp), %eax
        movl ST_BUFFER_LEN(%ebp), %ebx
        movl $0, %edi

                        # if a buffer with zero length was given
                        # to us, just leave
        cmpl $0, %ebx
        je end_convert_loop
convert_loop:
                        # get the current byte
        movb (%eax,%edi,1), %cl
                        # go to the next byte unless it is between
                        #'a' and 'z'
        cmpb $LOWERCASE_A, %cl
        jl next_byte
        cmpb $LOWERCASE_Z, %cl
        jg next_byte
                        # otherwise convert the byte to uppercase
        addb $UPPER_CONVERSION, %cl
                        # and store it back
        movb %cl, (%eax,%edi,1)

next_byte:
        incl %edi #next byte
        cmpl %edi, %ebx #continue unless
                        # we've reached the end
        jne convert_loop
end_convert_loop:
                        # no return value, just leave
        movl %ebp, %esp
        popl %ebp
        ret

# vim: expandtab sw=8 sts=8
</pre>
</blockquote>
</li>
</ul>
</blockquote>
<div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<p><strong>ToUpper BSS Version</strong></p>
<ul>
<li><p class="first">Rewrite the program so that it uses storage in the .bss section rather than the stack to store the file descriptors.</p>
<blockquote>
<pre class="code literal-block">
# -*- indent-tabs-mode: nil -*- (for Emacs)

# PURPOSE: This program converts an input file
# to an output file with all letters
# converted to uppercase.
#
# PROCESSING:
# 1) Open the input file
# 2) Open the output file
# 4) While we're not at the end of the input file
#    a) read part of file into our memory buffer
#    b) go through each byte of memory
#       if the byte is a lower-case letter,
#       convert it to uppercase
#    c) write the memory buffer to output file


        .section .data

        #######CONSTANTS########
        # system call numbers
        .equ SYS_OPEN, 5
        .equ SYS_WRITE, 4
        .equ SYS_READ, 3
        .equ SYS_CLOSE, 6
        .equ SYS_EXIT, 1

        # options for open (look at
        # /usr/include/asm/fcntl.h for
        # various values. You can combine them
        # by adding them or ORing them)
        # This is discussed at greater length
        # in &quot;Counting Like a Computer&quot;
        .equ O_RDONLY, 0
        .equ O_CREAT_WRONLY_TRUNC, 03101

        # standard file descriptors
        .equ STDIN, 0
        .equ STDOUT, 1
        .equ STDERR, 2

        # system call interrupt
        .equ LINUX_SYSCALL, 0x80
        .equ END_OF_FILE, 0 #This is the return value

        # of read which means we've
        # hit the end of the file
        .equ NUMBER_ARGUMENTS, 2

        .section .bss

        # Buffer - this is where the data is loaded into
        # from the data file and written from
        # into the output file. This should
        # never exceed 16,000 for various
        # reasons.
        .equ BUFFER_SIZE, 500
        .lcomm BUFFER_DATA, BUFFER_SIZE
        .lcomm FILEIN, 4
        .lcomm FILEOUT, 4

        .section .text

        # STACK POSITIONS
        .equ ST_SIZE_RESERVE, 8
        .equ ST_FD_IN, -4
        .equ ST_FD_OUT, -8
        .equ ST_ARGC, 0         # Number of arguments
        .equ ST_ARGV_0, 4       # Name of program
        .equ ST_ARGV_1, 8       # Input file name
        .equ ST_ARGV_2, 12      # Output file name
        .globl _start

_start:
        ### INITIALIZE PROGRAM ###
        # save the stack pointer

        movl %esp, %ebp

        # Allocate space for our file descriptors
        # on the stack
        subl $ST_SIZE_RESERVE, %esp

open_files:
open_fd_in:
                        ### OPEN INPUT FILE ###
                        # open syscall
        movl $SYS_OPEN, %eax
                        # input filename into %ebx
        movl ST_ARGV_1(%ebp), %ebx
                        # read-only flag
        movl $O_RDONLY, %ecx
                        # this doesn't really matter for reading
        movl $0666, %edx
                        # call Linux
        int $LINUX_SYSCALL
store_fd_in:
                        # save the given file descriptor
        movl %eax, FILEIN

open_fd_out:
                                ### OPEN OUTPUT FILE ###
                                # open the file
        movl $SYS_OPEN, %eax
                                # output filename into %ebx
        movl ST_ARGV_2(%ebp), %ebx
                                # flags for writing to the file
        movl $O_CREAT_WRONLY_TRUNC, %ecx
                                # mode for new file (if it's created)
        movl $0666, %edx
                                # call Linux
        int $LINUX_SYSCALL

store_fd_out:
                                # store the file descriptor here
        movl %eax, FILEOUT
                                # BEGIN MAIN LOOP
read_loop_begin:
                                   # READ IN A BLOCK FROM THE INPUT FILE
        movl $SYS_READ, %eax
        movl FILEIN, %ebx          # get the input file descriptor
        movl $BUFFER_DATA, %ecx    # the location to read into
        movl $BUFFER_SIZE, %edx    # the size of the buffer
        int $LINUX_SYSCALL         # Size of buffer read is returned in %eax
        cmpl $END_OF_FILE, %eax    # check for end of file marker
                                   # if found or on error, go to the end
        jle end_loop
continue_read_loop:
        ### CONVERT THE BLOCK TO UPPER CASE ###
        pushl $BUFFER_DATA      # location of buffer
        pushl %eax              # size of the buffer
        call convert_to_upper
        popl %eax               # get the size back
        addl $4, %esp           # restore %esp
        ### WRITE THE BLOCK OUT TO THE OUTPUT FILE ###
        movl %eax, %edx         # size of the buffer
        movl $SYS_WRITE, %eax
        movl FILEOUT, %ebx      # file to use
        movl $BUFFER_DATA, %ecx     # location of the buffer
        int $LINUX_SYSCALL
        jmp read_loop_begin

end_loop:
                                ###CLOSE THE FILES###
                                # NOTE - we don't need to do error checking
                                # on these, because error conditions
                                # don't signify anything special here
        movl $SYS_CLOSE, %eax
        movl FILEOUT, %ebx
        int $LINUX_SYSCALL
        movl $SYS_CLOSE, %eax
        movl FILEIN, %ebx
        int $LINUX_SYSCALL
                                ### EXIT ###
        movl $SYS_EXIT, %eax
        movl $0, %ebx
        int $LINUX_SYSCALL


#PURPOSE: This function actually does the
# conversion to upper case for a block
#
#INPUT: The first parameter is the location

# of the block of memory to convert
# The second parameter is the length of
# that buffer
#
#OUTPUT: This function overwrites the current
# buffer with the upper-casified version.
#
#VARIABLES:
# %eax - beginning of buffer
# %ebx - length of buffer
# %edi - current buffer offset
# %cl - current byte being examined
# (first part of %ecx)

        ### CONSTANTS ##
                                # The lower boundary of our search
        .equ LOWERCASE_A, 'a'
                                # The upper boundary of our search
        .equ LOWERCASE_Z, 'z'
                                # Conversion between upper and lower case
        .equ UPPER_CONVERSION, 'A' - 'a'
                                ### STACK STUFF ###
        .equ ST_BUFFER_LEN, 8   # Length of buffer
        .equ ST_BUFFER, 12      # actual buffer
convert_to_upper:
        pushl %ebp
        movl %esp, %ebp
                        ### SET UP VARIABLES ###
        movl ST_BUFFER(%ebp), %eax
        movl ST_BUFFER_LEN(%ebp), %ebx
        movl $0, %edi

                        # if a buffer with zero length was given
                        # to us, just leave
        cmpl $0, %ebx
        je end_convert_loop
convert_loop:
                        # get the current byte
        movb (%eax,%edi,1), %cl
                        # go to the next byte unless it is between
                        #'a' and 'z'
        cmpb $LOWERCASE_A, %cl
        jl next_byte
        cmpb $LOWERCASE_Z, %cl
        jg next_byte
                        # otherwise convert the byte to uppercase
        addb $UPPER_CONVERSION, %cl
                        # and store it back
        movb %cl, (%eax,%edi,1)

next_byte:
        incl %edi #next byte
        cmpl %edi, %ebx #continue unless
                        # we've reached the end
        jne convert_loop
end_convert_loop:
                        # no return value, just leave
        movl %ebp, %esp
        popl %ebp
        ret

# vim: expandtab sw=8 sts=8
</pre>
</blockquote>
</li>
</ul>
</blockquote>
<div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<p><strong>HeyNow</strong></p>
<ul>
<li><p class="first">Write a program that will create a file called heynow.txt and write the words “Hey diddle diddle!” into it.</p>
<blockquote>
<pre class="code literal-block">
# -*- indent-tabs-mode: nil -*- (for Emacs)

# PURPOSE:

        .section .data

        # File name and contents
file_name:
        .ascii &quot;heynow.txt\0&quot;
file_contents:
        .ascii &quot;Hey diddle diddle!\0&quot;

        #######CONSTANTS########
        # system call numbers
        .equ SYS_OPEN, 5
        .equ SYS_WRITE, 4
        .equ SYS_READ, 3
        .equ SYS_CLOSE, 6
        .equ SYS_EXIT, 1

        # options for open (look at
        # /usr/include/asm/fcntl.h for
        # various values. You can combine them
        # by adding them or ORing them)
        # This is discussed at greater length
        # in &quot;Counting Like a Computer&quot;
        .equ O_RDONLY, 0
        .equ O_CREAT_WRONLY_TRUNC, 03101

        # standard file descriptors
        .equ STDIN, 0
        .equ STDOUT, 1
        .equ STDERR, 2

        # system call interrupt
        .equ LINUX_SYSCALL, 0x80
        .equ END_OF_FILE, 0 #This is the return value

        # of read which means we've
        # hit the end of the file
        .equ NUMBER_ARGUMENTS, 2

        .section .bss

        # Buffer - this is where the data is loaded into
        # from the data file and written from
        # into the output file. This should
        # never exceed 16,000 for various
        # reasons.
        .equ BUFFER_SIZE, 500
        .lcomm BUFFER_DATA, BUFFER_SIZE

        .section .text

        # STACK POSITIONS
        .equ ST_SIZE_RESERVE, 8
        .equ ST_FD_OUT, -4
        .globl _start

_start:
        ### INITIALIZE PROGRAM ###
        # save the stack pointer

        movl %esp, %ebp

        # Allocate space for our file descriptors
        # on the stack
        subl $ST_SIZE_RESERVE, %esp

open_files:
open_fd_out:
                                ### OPEN OUTPUT FILE ###
                                # open the file
        movl $SYS_OPEN, %eax
                                # output filename into %ebx
        movl $file_name, %ebx
                                # flags for writing to the file
        movl $O_CREAT_WRONLY_TRUNC, %ecx
                                # mode for new file (if it's created)
        movl $0666, %edx
                                # call Linux
        int $LINUX_SYSCALL

store_fd_out:
                                # store the file descriptor here
        movl %eax, ST_FD_OUT(%ebp)

get_length:
        # text to write
        movl $file_contents, %ebx
        # counter
        movl $0, %edi


length_loop:
        # get byte
        movb (%ebx,%edi,1), %cl

        # if zero byte, string is done
        cmpb $0, %cl
        je loop_end

        # increment
        incl %edi
        jmp length_loop

loop_end:

        ### WRITE THE BLOCK OUT TO THE OUTPUT FILE ###
        movl %edi, %edx         # size of the buffer
        movl $SYS_WRITE, %eax
        movl ST_FD_OUT(%ebp), %ebx  # file to use
        movl $file_contents, %ecx     # location of the buffer
        int $LINUX_SYSCALL

close_files:
                                ###CLOSE THE FILES###
                                # NOTE - we don't need to do error checking
                                # on these, because error conditions
                                # don't signify anything special here
        movl $SYS_CLOSE, %eax
        movl ST_FD_OUT(%ebp), %ebx
        int $LINUX_SYSCALL

                                ### EXIT ###
        movl $SYS_EXIT, %eax
        movl $0, %ebx
        int $LINUX_SYSCALL


# vim: expandtab sw=8 sts=8
</pre>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
</div>
</div>
</body>
</html>
