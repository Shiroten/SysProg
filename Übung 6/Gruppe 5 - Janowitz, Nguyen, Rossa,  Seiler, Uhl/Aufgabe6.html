<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.14: http://docutils.sourceforge.net/" />
<title>Gruppe 5 - Übung 6</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7952 2016-07-26 18:15:59Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

.subscript {
  vertical-align: sub;
  font-size: smaller }

.superscript {
  vertical-align: super;
  font-size: smaller }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left, table.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right, table.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

table.align-center {
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

.align-top    {
  vertical-align: top }

.align-middle {
  vertical-align: middle }

.align-bottom {
  vertical-align: bottom }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #eeeeee }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

/* "booktabs" style (no vertical lines) */
table.docutils.booktabs {
  border: 0px;
  border-top: 2px solid;
  border-bottom: 2px solid;
  border-collapse: collapse;
}
table.docutils.booktabs * {
  border: 0px;
}
table.docutils.booktabs th {
  border-bottom: thin solid;
  text-align: left;
}

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="gruppe-5-ubung-6">
<h1 class="title">Gruppe 5 - Übung 6</h1>

<p>Von:    Ivo Janowitz, Nguyen Anh Quang, Tillman Rossa, Roman Seiler, Alexander Uhl</p>
<blockquote>
<div class="line-block">
<div class="line"><br /></div>
</div>
</blockquote>
<div class="section" id="aufgabe">
<h1>1. Aufgabe</h1>
<blockquote>
<p><strong>ASCII Umwandlung</strong></p>
<blockquote>
<ul>
<li><p class="first">Wie macht man aus einem Zahlenwert 0...9 das entsprechende ASCII Zeichen?</p>
<blockquote>
<p>Man addiert den ASCII Character für die Zahl '0' hinzu. Welches 0x30 oder 48 entspricht</p>
</blockquote>
</li>
<li><p class="first">Wie macht man im ASCII Code aus einem grossen Buchstaben einen kleinen Buchstaben?</p>
<blockquote>
<p>Durch die Addition von 'a'-'A' (0x61-0x41=0x20 entspricht 32 dezimal) wird aus einem großen Buchstabe ein kleiner.</p>
</blockquote>
</li>
</ul>
</blockquote>
<div class="line-block">
<div class="line"><br /></div>
</div>
</blockquote>
</div>
<div class="section" id="id1">
<h1>2. Aufgabe</h1>
<blockquote>
<p><strong>Character/Line Count</strong></p>
<blockquote>
<ul class="simple">
<li>Schreiben Sie ein Programm in Assembler, das die Anzahl der Zeichen und die Anzahl der Zeilen in einer Textdatei bestimmt und auf den Bildschirm (stdout) schreibt. Der Name der Datei wird als Argument an das Programm übergeben.</li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<blockquote>
<strong>write.s</strong></blockquote>
<pre class="code literal-block">
        .type write, &#64;function
        .globl write

.section .data
.section .text
        .equ  STDOUT, 1
        .equ  SYS_WRITE, 4

write:
    pushl %ebp
    movl  %esp, %ebp

    pushl 8(%ebp)
    call count_chars
    addl $4, %esp

    movl %eax, %edx
    movl $STDOUT, %ebx
    movl $SYS_WRITE, %eax
    movl 8(%ebp), %ecx
    int $0x80

    movl  %ebp, %esp
    popl  %ebp
    ret
</pre>
</blockquote>
<div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<blockquote>
<strong>convert_number.s</strong></blockquote>
<pre class="code literal-block">
        .type convert_number, &#64;function
        .globl convert_number

.section .data
.section .text

convert_number:
        ###CONSTANTS###
        .equ  ST_ASCII_BUFFER, 8
        .equ  ST_NUMBER, 12
        .equ ZERO, '0'

    pushl %ebp
    movl  %esp, %ebp

    movl  $0, %edi
    movl  ST_NUMBER(%ebp), %eax

convert_loop:
    movl  $10, %ebx
    movl  $0, %edx

    div %ebx                    #divides %eax by %ebx, stores modulo at %edx and result at %eax

    addl  $ZERO, %edx
    pushl %edx
    incl  %edi

    cmpl $0,%eax
    je   reverse

    jmp convert_loop

reverse:
    movl %edi, %eax
    movl $0, %edi
    movl ST_ASCII_BUFFER(%ebp), %ebx

reverse_loop:
    popl  (%ebx,%edi,1)
    incl  %edi
    cmpl  %edi, %eax
    je    convert_end
    jmp   reverse_loop

convert_end:
    movl  %ebp, %esp
    popl  %ebp
    ret
</pre>
</blockquote>
<div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<blockquote>
<strong>print.s</strong></blockquote>
<pre class="code literal-block">
        .type print, &#64;function
        .globl print

.section .data

        .equ BUFFER_SIZE, 500
        .lcomm BUFFER_DATA, BUFFER_SIZE
        .lcomm LINE_COUNT_ASCII, 100
        .lcomm CHAR_COUNT_ASCII, 100

.section .text

line_text:
        .asciz &quot;Anzahl Zeilen: &quot;

char_text:
        .asciz &quot;Anzahl Character: &quot;

blank_text:
        .asciz &quot;\n&quot;

        ###CONSTANTS###
        .equ  ST_LINE_COUNT, 12
        .equ  ST_CHAR_COUNT, 8

print:
    pushl %ebp
    movl  %esp, %ebp

    pushl ST_CHAR_COUNT(%ebp)
    pushl $CHAR_COUNT_ASCII
    call convert_number
    addl $8, %esp

    pushl ST_LINE_COUNT(%ebp)
    pushl $LINE_COUNT_ASCII
    call convert_number
    addl $8, %esp

    pushl $char_text
    call  write
    addl  $4, %esp

    pushl $CHAR_COUNT_ASCII
    call  write
    addl  $4, %esp

    pushl $blank_text
    call  write
    addl  $4, %esp

    pushl $line_text
    call  write
    addl  $4, %esp

    pushl $LINE_COUNT_ASCII
    call  write
    addl  $4, %esp

    pushl $blank_text
    call  write
    addl  $4, %esp


finished_reading:
    movl  %ebp, %esp
    popl  %ebp
    ret


</pre>
</blockquote>
<div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<blockquote>
<strong>char_counter.s</strong></blockquote>
<pre class="code literal-block">
        .type char_counter, &#64;function
        .globl char_counter

.section .data

        .equ BUFFER_SIZE, 500

        .lcomm BUFFER_DATA, BUFFER_SIZE

.section .text

        ###CONSTANTS##
        .equ  LOWERCASE_A, 'a'
        .equ  LOWERCASE_Z, 'z'
        .equ  UPPERCASE_A, 'A'
        .equ  UPPERCASE_Z, 'Z'

        ###STACK CONSTANTS###
        .equ  ST_BUFFER_LEN, 8 #Length of buffer
        .equ  ST_BUFFER, 12    #actual buffer

char_counter:
        pushl %ebp
        movl  %esp, %ebp
        subl  $4, %esp
        movl $0, -4(%ebp)

        movl  ST_BUFFER(%ebp), %eax
        movl  ST_BUFFER_LEN(%ebp), %ebx
        movl  $0, %edi

        cmpl  $0, %ebx
        je    char_end_convert_loop

char_loop:
        movb  (%eax,%edi,1), %cl

        cmpb  $UPPERCASE_A, %cl         #Überspringe Zeichen kleiner als A(0x41)
        jl    char_next_byte
        cmpb  $LOWERCASE_Z, %cl         #Überspringe Zeichen größer  als z(0x7A)
        jg    char_next_byte

        cmpb  $UPPERCASE_Z, %cl         #Wenn kleiner als Z(0x5A) incrementiere
        jle   char_increment

        cmpb  $LOWERCASE_A, %cl         #Wenn größer  als a(0x61) incrementiere
        jge   char_increment

        jmp   char_next_byte            #Ansonsten überspringe Zeichen


char_increment:
        incl -4(%ebp)

char_next_byte:
        incl  %edi              #next byte
        cmpl  %edi, %ebx        #continue unless
                                #we've reached the
                                #end
        jne   char_loop

char_end_convert_loop:
        movl  -4(%ebp), %eax
        movl  %ebp, %esp
        popl  %ebp
        ret
</pre>
</blockquote>
<div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<blockquote>
<strong>line_counter.s</strong></blockquote>
<pre class="code literal-block">
        .type line_counter, &#64;function
        .globl line_counter

.section .data

        .equ BUFFER_SIZE, 500
        .lcomm BUFFER_DATA, BUFFER_SIZE

.section .text

        ###CONSTANTS##
        #ASCII Value of linebreak
        .equ  LINEBREAK, 10

        ###STACK CONSTANTS###
        .equ  ST_BUFFER_LEN, 8 #Length of buffer
        .equ  ST_BUFFER, 12    #actual buffer

line_counter:
        pushl %ebp
        movl  %esp, %ebp
        subl  $4, %esp
        movl $0, -4(%ebp)

        movl  ST_BUFFER(%ebp), %eax
        movl  ST_BUFFER_LEN(%ebp), %ebx
        movl  $0, %edi

        cmpl  $0, %ebx
        je    line_end_convert_loop

line_loop:
        movb  (%eax,%edi,1), %cl
        cmpb  $LINEBREAK, %cl
        jne   line_next_byte

        incl -4(%ebp)

line_next_byte:
        incl  %edi              #next byte
        cmpl  %edi, %ebx        #continue unless
                                #we've reached the
                                #end
        jne   line_loop

line_end_convert_loop:
        movl  -4(%ebp), %eax
        movl  %ebp, %esp
        popl  %ebp
        ret
</pre>
</blockquote>
<div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<blockquote>
<strong>character_counter.s</strong></blockquote>
<pre class="code literal-block">
.include &quot;linux.s&quot;

.section .data

        .equ BUFFER_SIZE, 500
        .equ O_RDONLY, 0
        .equ CHARCOUNT, -4
        .equ LINECOUNT, -8
        .lcomm BUFFER_DATA, BUFFER_SIZE
        .lcomm FILEIN, 4

.section .text

char_count:
        .long 0

line_count:
        .long 0

        .globl _start

_start:
        movl  %esp, %ebp
        subl $8, %esp
        movl $0, CHARCOUNT(%ebp)
        movl $0, LINECOUNT(%ebp)

open_file:
        cmp $2, (%ebp)
        jne wrong_arguments

        movl  $SYS_OPEN, %eax
        movl  8(%ebp), %ebx   #Get Filename from Stack
        movl  $O_RDONLY, %ecx
        movl  $0666, %edx
        int   $LINUX_SYSCALL

store_fd_in:
        movl  %eax, FILEIN

read_loop_begin:
        movl  $SYS_READ, %eax
        movl  FILEIN, %ebx
        movl  $BUFFER_DATA, %ecx
        movl  $BUFFER_SIZE, %edx
        int   $LINUX_SYSCALL

        cmpl  $END_OF_FILE, %eax
        jle   end_loop

continue_read_loop:
        ### Counter Words
        pushl $BUFFER_DATA     #location of buffer
        pushl %eax             #size of the buffer
        call  char_counter
        addl  %eax,CHARCOUNT(%ebp)
        popl  %eax             #get the size back
        addl  $4, %esp         #restore %esp

        ### Count Linebreaks
        pushl $BUFFER_DATA     #location of buffer
        pushl %eax             #size of the buffer
        call  line_counter
        addl  %eax,LINECOUNT(%ebp)
        popl  %eax             #get the size back
        addl  $4, %esp         #restore %esp

        jmp   read_loop_begin

end_loop:
        pushl LINECOUNT(%ebp)
        pushl CHARCOUNT(%ebp)

        call  print
        addl  $8, %esp

        movl  $SYS_CLOSE, %eax
        movl  FILEIN, %ebx
        int   $LINUX_SYSCALL

        movl  $SYS_EXIT, %eax
        movl  $0, %ebx
        int   $LINUX_SYSCALL

wrong_arguments:
        movl  $SYS_EXIT, %eax
        movl  (%ebp), %ebx
        int   $LINUX_SYSCALL






</pre>
</blockquote>
</blockquote>
</blockquote>
</div>
<div class="section" id="id2">
<h1>3. Aufgabe</h1>
<blockquote>
<p><strong>Strukturdiagramm Read-Records</strong></p>
<blockquote>
<ul class="simple">
<li>Wie ist das Programm im Bartlett in Kapitel 6 strukturiert? Zeichnen Sie in einem Diagramm die Abhängigkeiten der einzelnen Dateien. Mit A ==&gt; B kennzeichnen Sie, dass Datei B die Quelltextdatei A inkludiert. Mit A + B kennzeichnen Sie, dass die Objektdateien A und B miteinander gelinkt werden.</li>
</ul>
</blockquote>
<img alt="teil3.png" src="teil3.png" />
<div class="line-block">
<div class="line"><br /></div>
</div>
</blockquote>
</div>
<div class="section" id="id3">
<h1>4. Aufgabe</h1>
<blockquote>
<p><strong>Going Further - Kapitel 6</strong></p>
<blockquote>
<ul>
<li><p class="first">Schreiben Sie das Programm um, so dass Kommandozeilenargumente verwendet werden.</p>
<blockquote>
<blockquote>
<p><strong>add-year.s</strong></p>
</blockquote>
<pre class="code literal-block">

    .include &quot;linux.s&quot;
    .include &quot;record-def.s&quot;

    .section .data

input_file_name:
    .ascii &quot;test.dat\0&quot;

output_file_name:
    .ascii &quot;testout.dat\0&quot;
    .section .bss
    .lcomm record_buffer, RECORD_SIZE
    # Stack offsets of local variables
    .equ ST_INPUT_DESCRIPTOR, -4
    .equ ST_OUTPUT_DESCRIPTOR, -8
    .equ ST_ARG_1, 8
    .equ ST_ARG_2, 12

    .section .text
    .globl _start
_start:
    # Copy stack pointer and make room for local variables
    movl %esp, %ebp
    subl $8, %esp
    # Open file for reading
    movl $SYS_OPEN, %eax
    movl ST_ARG_1(%ebp), %ebx
    movl $0, %ecx
    movl $0666, %edx
    int $LINUX_SYSCALL
    movl %eax, ST_INPUT_DESCRIPTOR(%ebp)
    # Open file for writing
    movl $SYS_OPEN, %eax
    movl ST_ARG_2(%ebp), %ebx
    movl $0101, %ecx

    movl $0666, %edx
    int $LINUX_SYSCALL
    movl %eax, ST_OUTPUT_DESCRIPTOR(%ebp)
loop_begin:
    pushl ST_INPUT_DESCRIPTOR(%ebp)
    pushl $record_buffer
    call read_record
    addl $8, %esp
    # Returns the number of bytes read.
    # If it isn't the same number we
    # requested, then it's either an
    # end-of-file, or an error

    # quitting
    cmpl $RECORD_SIZE, %eax
    jne loop_end

    # Increment the age
    incl record_buffer + RECORD_AGE

    # Write the record out
    pushl ST_OUTPUT_DESCRIPTOR(%ebp)
    pushl $record_buffer
    call write_record
    addl $8, %esp
    jmp loop_begin
loop_end:
    movl $SYS_EXIT, %eax
    movl $0, %ebx
    int $LINUX_SYSCALL


# vim: expandtab ts=4 sw=4
</pre>
</blockquote>
</li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<blockquote>
<strong>read-records.s</strong></blockquote>
<pre class="code literal-block">

    .include &quot;linux.s&quot;
    .include &quot;record-def.s&quot;

    .section .data
file_name:
    .ascii &quot;est.dat\0&quot;
    .section .bss
    .lcomm record_buffer, RECORD_SIZE

    .section .text
    #Main program
    .globl _start
_start:
    #These are the locations on the stack where
    #we will store the input and output descriptors
    #(FYI - we could have used memory addresses in
    #a .data section instead)
    .equ ST_INPUT_DESCRIPTOR, -4
    .equ ST_OUTPUT_DESCRIPTOR, -8
    .equ ST_ARG_1, 8

    #Copy the stack pointer to %ebp
    movl %esp, %ebp
    #Allocate space to hold the file descriptors
    subl $8, %esp
    #Open the file
    movl $SYS_OPEN, %eax
    movl ST_ARG_1(%ebp), %ebx
    movl $0, %ecx #This says to open read-only

    movl $0666, %edx
    int $LINUX_SYSCALL
    #Save file descriptor
    movl %eax, ST_INPUT_DESCRIPTOR(%ebp)
    #Even though it's a constant, we are
    #saving the output file descriptor in
    #a local variable so that if we later
    #decide that it isn't always going to
    #be STDOUT, we can change it easily.
    movl $STDOUT, ST_OUTPUT_DESCRIPTOR(%ebp)
record_read_loop:
    pushl ST_INPUT_DESCRIPTOR(%ebp)
    pushl $record_buffer
    call read_record
    addl $8, %esp
    #Returns the number of bytes read.
    #If it isn't the same number we
    #requested, then it's either an
    #end-of-file, or an error, so we're
    #quitting
    cmpl $RECORD_SIZE, %eax
    jne finished_reading
    #Otherwise, print out the first name
    #but first, we must know it's size
    pushl $RECORD_FIRSTNAME + record_buffer
    call count_chars
    addl $4, %esp

    movl %eax, %edx
    movl ST_OUTPUT_DESCRIPTOR(%ebp), %ebx
    movl $SYS_WRITE, %eax
    movl $RECORD_FIRSTNAME + record_buffer, %ecx
    int $LINUX_SYSCALL
    pushl ST_OUTPUT_DESCRIPTOR(%ebp)
    call write_newline
    addl $4, %esp
    jmp record_read_loop
finished_reading:
    movl $SYS_EXIT, %eax
    movl $0, %ebx
    int $LINUX_SYSCALL

# vim: expandtab ts=4 sw=4
</pre>
</blockquote>
<div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<blockquote>
<strong>write-records.s</strong></blockquote>
<pre class="code literal-block">
.include &quot;linux.s&quot;
.include &quot;record-def.s&quot;

.section .data
#Constant data of the records we want to write
#Each text data item is padded to the proper
#length with null (i.e. 0) bytes.
#.rept is used to pad each item. .rept tells
#the assembler to repeat the section between
#.rept and .endr the number of times specified.
#This is used in this program to add extra null
#characters at the end of each field to fill
#it up
record1:
.ascii &quot;Fredrick\0&quot;
.rept 31 #Padding to 40 bytes
.byte 0
.endr
.ascii &quot;Bartlett\0&quot;

.rept 31 #Padding to 40 bytes
.byte 0
.endr
.ascii &quot;4242 S Prairie\nTulsa, OK 55555\0&quot;
.rept 209 #Padding to 240 bytes
.byte 0
.endr
.long 45
record2:
.ascii &quot;Marilyn\0&quot;
.rept 32 #Padding to 40 bytes
.byte 0
.endr
.ascii &quot;Taylor\0&quot;
.rept 33 #Padding to 40 bytes
.byte 0
.endr
.ascii &quot;2224 S Johannan St\nChicago, IL 12345\0&quot;
.rept 203 #Padding to 240 bytes
.byte 0
.endr
.long 29
record3:
.ascii &quot;Derrick\0&quot;
.rept 32 #Padding to 40 bytes
.byte 0
.endr

.ascii &quot;McIntire\0&quot;
.rept 31 #Padding to 40 bytes
.byte 0
.endr
.ascii &quot;500 W Oakland\nSan Diego, CA 54321\0&quot;
.rept 206 #Padding to 240 bytes
.byte 0
.endr
.long 36
#This is the name of the file we will write to
file_name:
.ascii &quot;est.dat\0&quot;

.section .text
.equ ST_FILE_DESCRIPTOR, -4
.equ ST_ARG_1, 8

.globl _start
_start:
#Copy the stack pointer to %ebp
movl %esp, %ebp

#Allocate space to hold the file descriptor
subl $4, %esp

#Open the file
movl $SYS_OPEN, %eax
movl ST_ARG_1(%ebp), %ebx
movl $0101, %ecx #This says to create if it
#doesn't exist, and open for
#writing
movl $0666, %edx
int $LINUX_SYSCALL
#Store the file descriptor away
movl %eax, ST_FILE_DESCRIPTOR(%ebp)

#Write the first record
pushl ST_FILE_DESCRIPTOR(%ebp)
pushl $record1
call write_record
addl $8, %esp
#Write the second record
pushl ST_FILE_DESCRIPTOR(%ebp)
pushl $record2
call write_record
addl $8, %esp
#Write the third record
pushl ST_FILE_DESCRIPTOR(%ebp)
pushl $record3
call write_record
addl $8, %esp
#Close the file descriptor
movl $SYS_CLOSE, %eax
movl ST_FILE_DESCRIPTOR(%ebp), %ebx
int $LINUX_SYSCALL
#Exit the program
movl $SYS_EXIT, %eax
movl $0, %ebx
int $LINUX_SYSCALL
</pre>
</blockquote>
<div class="line-block">
<div class="line"><br /></div>
</div>
</blockquote>
<p><strong>Error Catch</strong></p>
<blockquote>
<ul class="simple">
<li>Fangen Sie Fehler ab, die beim Öffnen der Dateien auftreten können. Welche Fehlercodes es gibt, finden Sie in der man page &quot;man 2 open&quot;. Sie können einen Schreibschutzfehler hervorrufen, wenn Sie die Datei als normaler Anwender an einem nicht erlaubten Ort öffnen, z.B. mit dem Pfad &quot;/meine-datei.txt&quot;.</li>
</ul>
<blockquote>
<pre class="code literal-block">
Todo: Replace Dummy
</pre>
</blockquote>
</blockquote>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p><strong>Records with lseek</strong></p>
<blockquote>
<ul class="simple">
<li>Schreiben Sie ein Programm mit dem Sie auswählen können, welcher Datensatz ausgegeben werden soll. Sie geben auf der Kommandozeile einfach die Nummer 0, 1, 2, ... an, dann wird der jeweilige Datensatz ausgegeben. Mit dem Systemaufruf lseek() können Sie schnell an eine beliebige Stelle in der Datei gehen. Der Funktionscode für lseek in Register eax ist 19. Siehe &quot;man 2 lseek&quot;.</li>
</ul>
<blockquote>
<pre class="code literal-block">
        .include &quot;record-def.s&quot;
        .include &quot;linux.s&quot;

#PURPOSE:   This function reads a record from the file
#           descriptor
#
#INPUT:     The file descriptor and a buffer
#
#OUTPUT:    This function writes the data to the buffer
#           and returns a status code.
#
#STACK LOCAL VARIABLES
        .equ ST_READ_BUFFER, 8
        .equ ST_FILEDES, 12
        .section .text
        .globl read_record
        .type read_record, &#64;function
read_record:
        pushl %ebp
        movl  %esp, %ebp

        pushl %ebx
        movl  ST_FILEDES(%ebp), %ebx
        movl  ST_READ_BUFFER(%ebp), %ecx
        movl  $RECORD_SIZE, %edx
        movl  $SYS_READ, %eax
        int   $LINUX_SYSCALL

        #NOTE - %eax has the return value, which we will
        #       give back to our calling program
        popl  %ebx

        movl  %ebp, %esp
        popl  %ebp
        ret
</pre>
</blockquote>
</blockquote>
</blockquote>
</div>
</div>
</body>
</html>
